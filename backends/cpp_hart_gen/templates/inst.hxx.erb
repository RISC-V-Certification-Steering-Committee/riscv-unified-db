#pragma once

<%- ilist = cfg_arch.fully_configured? ? cfg_arch.transitive_implemented_instructions : cfg_arch.instructions -%>

<%
  def extract_decode(bits,inst)
    bits.map do |r|
      if r.is_a?(Integer)
        "extract<#{r}, 1, #{inst.encoding_width}>(m_encoding)"
      else
        "extract<#{r.first}, #{r.size}, #{inst.encoding_width}>(m_encoding)"
      end
    end.join(" || ")
  end
-%>

namespace udb {
  template <typename T>
  concept Is32 = requires(T value) { { value == 32} -> std::is_same<booL>; };

  template <typename T>
  concept Is32 = requires(T value) { { value == 64} -> std::is_same<booL>; };


  <%- ilist.each do |inst| -%>
  <%- needs_rv32 = inst.rv32? && cfg_arch.possible_xlens.include?(32) -%>
  <%- needs_rv64 = inst.rv64? && cfg_arch.possible_xlens.include?(64) -%>
  template <unsigned XLEN>
  class <%= name_of(:inst, cfg_arch, inst.name) %> : public InstBase {
  public:
    <%= name_of(:inst, cfg_arch, inst.name) %>(<%= name_of(:hart, cfg_arch) %>* parent, XReg pc, uint64_t encoding)
      : InstBase(pc, encoding),
        m_parent(parent)
    {
    }

    virtual ~<%= name_of(:inst, cfg_arch, inst.name) %>() {}

    <%= name_of(:hart, cfg_arch) %>* parent() { return m_parent; }

    size_t enc_len() const override { return <%= inst.encoding_width %>; }

    //
    // Decode variables
    //
    <%- if needs_rv32 && needs_rv64 -%>
    <%- inst.decode_variables(32).each do |dv| -%>
    Bits<<%= dv.size %> <%= dv.name %>() const requires Is32<XLEN> {
      <%= extract_decode(dv.bits,inst) %>;
    }
    <%- end -%>
    <%- inst.decode_variables(64).each do |dv| -%>
    Bits<<%= dv.size %> <%= dv.name %>() const requires Is64<XLEN> {
      <%= extract_decode(dv.bits,inst) %>;
    }
    <%- end -%>
    <%- elsif needs_rv32 -%>
    <%- inst.decode_variables(32).each do |dv| -%>
    Bits<<%= dv.size %> <%= dv.name %>() const {
      <%= extract_decode(dv.bits,inst) %>;
    }
    <%- end -%>
    <%- else -%>
    <%- inst.decode_variables(64).each do |dv| -%>
    Bits<<%= dv.size %> <%= dv.name %>() const {
      <%= extract_decode(dv.bits,inst) %>;
    }
    <%- end -%>
    <%- end -%>


    void execute() override {

      <%- if inst.operation_ast(cfg_arch.symtab).nil? -%>
      assert(!"There is no operation() defined for this instruction");
      <%- else -%>
      <%- if !inst.base.nil? -%>
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, inst.base) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, inst.base, pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 6) %>
      <%- elsif !cfg_arch.multi_xlen? -%>
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, cfg_arch.possible_xlens[0]) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, cfg_arch.possible_xlens[0], pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 6) %>
      <%- else -%>
        if (m_parent->xlen() == 32) {
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, 32) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, 32, pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 8) %>
      } else {
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, 64) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, 64, pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 8) %>
      }
      <%- end -%>
      <%- end -%>
    }

  private:
    <%= name_of(:hart, cfg_arch) %> * const m_parent;
  };
  <%- end -%>
}

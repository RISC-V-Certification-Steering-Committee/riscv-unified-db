#pragma once

#include <udb/bits.hpp>
#include <type_traits>
#include <udb/util.hpp>

<%- ilist = cfg_arch.fully_configured? ? cfg_arch.transitive_implemented_instructions : cfg_arch.instructions -%>

<%
  def extract_decode(bits,inst)
    bits.map do |r|
      if r.is_a?(Integer)
        "extract<#{r}, 1, #{inst.encoding_width}>(m_encoding)"
      else
        "extract<#{r.first}, #{r.size}, #{inst.encoding_width}>(m_encoding)"
      end
    end.join(" || ")
  end
-%>

namespace udb {

  <%- ilist.each do |inst| -%>
  <%- needs_rv32 = inst.rv32? && cfg_arch.possible_xlens.include?(32) -%>
  <%- needs_rv64 = inst.rv64? && cfg_arch.possible_xlens.include?(64) -%>
  template <unsigned XLEN>
  class <%= name_of(:inst, cfg_arch, inst.name) %> : public InstBase {
  public:
    using XReg = Bits<<%= name_of(:hart, cfg_arch) %>::MXLEN>;
    <%= name_of(:inst, cfg_arch, inst.name) %>(<%= name_of(:hart, cfg_arch) %>* parent, XReg pc, uint64_t encoding)
      : InstBase(pc, encoding),
        m_parent(parent)
    {
    }

    virtual ~<%= name_of(:inst, cfg_arch, inst.name) %>() {}

    <%= name_of(:hart, cfg_arch) %>* parent() { return m_parent; }

    size_t enc_len() const override { return <%= inst.encoding_width %>; }

    //
    // Decode variables
    //
    <%- if needs_rv32 && needs_rv64 -%>
    <%- inst.decode_variables(32).each do |dv| -%>
    Bits<<%= dv.size %>> <%= dv.name %>() const requires (XLEN==32) {
      return <%= extract_decode(dv.bits,inst) %>;
    }
    <%- end -%>
    <%- inst.decode_variables(64).each do |dv| -%>
    Bits<<%= dv.size %>> <%= dv.name %>() const requires (XLEN==64) {
      return <%= extract_decode(dv.bits,inst) %>;
    }
    <%- end -%>
    <%- elsif needs_rv32 -%>
    <%- inst.decode_variables(32).each do |dv| -%>
    Bits<<%= dv.size %>> <%= dv.name %>() const {
      return <%= extract_decode(dv.bits,inst) %>;
    }
    <%- end -%>
    <%- else -%>
    <%- inst.decode_variables(64).each do |dv| -%>
    Bits<<%= dv.size %>> <%= dv.name %>() const {
      return <%= extract_decode(dv.bits,inst) %>;
    }
    <%- end -%>
    <%- end -%>

#define __UDB_FUNC_CALL m_parent->
#define __UDB_CSR_BY_ADDR(addr) m_parent->csr(addr)
#define __UDB_CSR_BY_NAME(csr_name) m_parent->m_csrs.csr_name


    void execute() override {

      <%- if inst.operation_ast(cfg_arch.symtab).nil? -%>
      assert(!"There is no operation() defined for this instruction");
      <%- else -%>
      <%- if !inst.base.nil? -%>
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, inst.base) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, inst.base, pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 6) %>
      <%- elsif !cfg_arch.multi_xlen? -%>
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, cfg_arch.possible_xlens[0]) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, cfg_arch.possible_xlens[0], pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 6) %>
      <%- else -%>
        if (m_parent->xlen() == 32) {
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, 32) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, 32, pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 8) %>
      } else {
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, 64) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, 64, pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 8) %>
      }
      <%- end -%>
      <%- end -%>
    }

#undef __UDB__FUNC__CALL
#undef __UDB_CSR_BY_ADDR
#undef __UDB_CSR_BY_NAME

  private:
    <%= name_of(:hart, cfg_arch) %> * const m_parent;
  };
  <%- end -%>
}

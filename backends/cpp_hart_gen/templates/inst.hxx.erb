#pragma once

<%- ilist = cfg_arch.fully_configured? ? cfg_arch.transitive_implemented_instructions : cfg_arch.instructions -%>

namespace udb {
  <%- ilist.each do |inst| -%>
  class <%= name_of(:inst, cfg_arch, inst.name) %> : public InstBase {
  public:
    <%= name_of(:inst, cfg_arch, inst.name) %>(<%= name_of(:hart, cfg_arch) %>* parent, XReg pc, uint64_t encoding)
      : InstBase(pc, encoding),
        m_parent(parent)
    {
    }

    virtual ~<%= name_of(:inst, cfg_arch, inst.name) %>() {}

    <%= name_of(:hart, cfg_arch) %>* parent() { return m_parent; }

    size_t enc_len() const override { return <%= inst.encoding_width %>; }

    void execute() override {

      <%- if inst.operation_ast(cfg_arch.symtab).nil? -%>
      assert(!"There is no operation() defined for this instruction");
      <%- else -%>
      <%- if !inst.base.nil? -%>
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, inst.base) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, inst.base, pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 6) %>
      <%- elsif !cfg_arch.multi_xlen? -%>
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, cfg_arch.possible_xlens[0]) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, cfg_arch.possible_xlens[0], pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 6) %>
      <%- else -%>
        if (m_parent->xlen() == 32) {
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, 32) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, 32, pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 8) %>
      } else {
        <%- pruned_ast = inst.pruned_operation_ast(cfg_arch.symtab, 64) -%>
        <%- symtab = inst.fill_symtab(cfg_arch.symtab, 64, pruned_ast) -%>
        <%= pruned_ast.gen_cpp(symtab, 8) %>
      }
      <%- end -%>
      <%- end -%>
    }

  private:
    <%= name_of(:hart, cfg_arch) %> * const m_parent;
  };
  <%- end -%>
}

#pragma once

#include <cstdint>

#include <nlohmann/json-schema.hpp>

#include "udb/hart.hpp"
#include "udb/cfgs/<%= cfg_arch.name %>/params.hxx"
#include "udb/cfgs/<%= cfg_arch.name %>/csr_container.hxx"

<%- hart_name = name_of(:hart, cfg_arch) -%>

namespace udb {
  class <%= hart_name -%> : public HartBase {
    <%- csrs = cfg_arch.fully_configured? ? cfg_arch.implemented_csrs : cfg_arch.csrs -%>
    <%- csrs.each do |csr| -%>
    friend class <%= name_of(:csr, cfg_arch, csr.name) %>;
    <%- fields = cfg_arch.fully_configured? ? csr.implemented_fields(cfg_arch) : csr.fields -%>
    <%- fields.each do |field| -%>
    friend class <%= name_of(:csr_field, cfg_arch, csr.name, field.name) %>;
    <%- end -%>
    <%- end -%>

    public:
      static constexpr unsigned MXLEN = <%= cfg_arch.mxlen.nil? ? 64 : cfg_arch.mxlen %>;
      using XReg = Bits<MXLEN>;

      <%= hart_name -%>(uint64_t hart_id, Memory& mem, const nlohmann::json& cfg)
        : HartBase(hart_id, mem, cfg),
          m_params(<%= name_of(:params, cfg_arch) %>(cfg)),
          m_csrs(this)
      {
        m_xregs[0].makeZeroReg();
      }

      unsigned xlen() {
        return MXLEN;
      }

      void set_pc(uint64_t new_pc) override {
        m_pc = new_pc;
      }

      void set_next_pc(uint64_t next_pc) override {
        m_next_pc = next_pc;
      }

      uint64_t pc() const override { return m_pc; }

      void advance_pc() override {
        m_pc = m_next_pc;
      }

      unsigned mxlen() override { return MXLEN; }

      uint64_t xreg(unsigned num) const override { return m_xregs[num].get(); }

      XRegister<MXLEN>& xregRef(unsigned num) { return m_xregs[num]; }

      void set_xreg(unsigned num, uint64_t value) override {
        m_xregs[num] = value; // zero index check happens in XRegister class
      }

      void printState(FILE* out = stdout) const override;

    CsrBase* csr(unsigned address) override {
      return nullptr;
      // auto it = m_csr_map.find(address);
      // if (it == m_csr_map.end()) {
      //   return nullptr;
      // }
      // return it->second;
    }

    const CsrBase* csr(unsigned address) const override {
      return nullptr;
      // auto it = m_csr_map.find(address);
      // if (it == m_csr_map.end()) {
      //   return nullptr;
      // }
      // return it->second;
    }

    private:
      XReg m_pc;
      XReg m_next_pc;
      std::array<XRegister<MXLEN>, 32> m_xregs;

      <%= name_of(:params, cfg_arch) %> m_params;
      <%= name_of(:csr_container, cfg_arch) %> m_csrs;
  };
}
